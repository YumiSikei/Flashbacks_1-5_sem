;Составить подпрограмму с именем SetCler типа
;   Procedure (var S:LONGWORD; L:LONGWORD; N:LONGWORD; P:LONGWORD)
;выполняющую установку разряда N битовой строки S
;в ноль, если P=0, в единицу,если P не равен 0.


; заметки(с пробелом!)
; LONGWORD занимает 4 байта, а значит является DWORD(DD)

.386 
; директива, указывающая, что тип процессора Intel Pentium

.model FLAT,PASCAL 
; параметр flat указывает компилятору на то, что
; будет использоваться 32-разрядная линейная адресация
; Параметр соглашение_о_вызовах используется для определения способа 
; передачи параметров при вызове процедуры из других языков. У нас ассемблер

PUBLIC SetCler
; Каждая процедура или функция Турбо  Ассемблера,  которую  вы
; хотите сделать доступной в программе Турбо Паскаля, должна объяв-
; ляться, как идентификатор PUBLIC, и ей должно  соответствовать  в
; программе описание external (внешняя). Синтаксис описания внешней
; процедуры или функции в  Турбо  Паскале  аналогичен  опережающему
; (forward) описанию

.CODE
; Выше было просто объявление, что подпрограмма SetCler - должна запуститься
; под турбоделфи, а теперь пишем ее определение.

;Макрос proc создает кадр стека, чтобы можно было обрашаться к параметрам
; функции по именам. Если тебе это не нужно делай так
SetCler PROC
  PUSH EBP
  MOV EBP,ESP            
  
 

   ; ptr - Операция назначения типа. Результатом будет ссылка на память
   ; со значением выражения, следующего за операцией и типом выражения
   ; перед операцией. S, L, N, P - произвольные имена переменных, логично.

   ; В случае с процессорами Intel, ровно как и со многими другими архитетурами,
   ; стек растет в направлении меньших адресов памяти. Поэтому верхушка,
   ; в данном случае, соответствует наименьшему адресу в стеке. Какой гений это придумал, какой блин гений
   
   ; Здесь знак +, что означает, что переменные являются нелокальными - это
   ; аргументы функций. Но сами S,
   
   
    ; Директива equ позволяет назначать имена переменных и констант. Причём 
	; работает это как дефайн в Си.
	
	; По поводу числе +8, 12 и т.д. Если подпрограмма является far или near, то 
	; написав надпись PROC(во время определения функции), мы автоматически занесем
	; в стек 4 или 2 байта соответственно. Сама EBP весит 4 байта. Мы его запушили
	; Отсюда число +8. Теперь что касается +12, +16, +20. По соглашению паскаля
	; параметры передаются в функцию в прямом порядке, поэтому и обращаемся мы к ним так
  S EQU DWORD PTR[EBP+20]         ;наша строка
  L EQU DWORD PTR[EBP+16]         ;длина строки
  N EQU DWORD PTR[EBP+12]         ;номер разряда
  P EQU DWORD PTR[EBP+8]          ;параметр
  
  PUSH ESI

  MOV ESI,N                  
  MOV EBX,S             
  CMP ESI,32
  JNA M0  ; Если номер разряда меньше или равен 32, то в М0
  
  SUB ESI,32 ; Иначе номер разряда -= 32;
  ADD EBX,4 ; смещаем адрес строки на 4 байта вправо(как раз уйдет 32 бита)

M0:
  CMP P,0                       ;сравниваем режим с нулем
  JE M1                         ;если равно, то переходим на метку M1
  BTS [EBX], ESI                ;установка бита в 1
  ; Команда BTS сохраняет значение бита, из первого операнда со смещением,
  ; указанным вторым операндом, во флаге CF, а затем устанавливает этот бит
  ; в 1. В нашем случае [EBX] - адрес строки. ESI - разряд. 
  JMP M2
M1:
  BTR [EBX], ESI                ;установка бита в 0
  ; извлечение значения заданного бита в флаг cf и
  ;  изменение его значения на нулевое.

M2:
  POP ESI         ;восстанавливаем регистры
  POP EBP
  RET 16
  ; RET N(где N - это число байт передаваемых,  то есть за-
  ; несенных в стек, параметров). Как я понимаю ret - умный удалятор из стека
  ; Этакий всесильный pop... Хотя наверняка если указать невозможное число, не
  ; кратное двойке все крашнется...
  
  ; По соглашению паскаля мы должны сами очищать память. RET это и делает
  ; Прошу заметить, что это процедура и тут ничего не должно было вернуться
SetCler ENDP
END