;Составить подпрограмму с именем X_U_Y типа
;   Procedure (var X: LONGWORD; const Y:LONGWORD; L:LONGWORD)
;выполн€ющую объединение битовых строк X:=X U Y длины L.

.386
.model FLAT,PASCAL
PUBLIC X_U_Y

.CODE
X_U_Y PROC

; Тут был нарушен порядок. Как это вообще работало? 
PUSH EBP                
MOV EBP,ESP  

X EQU DWORD PTR[EBP+16]           ;первая строка
Y EQU DWORD PTR[EBP+12]           ;вторая строка
L EQU DWORD PTR[EBP+8]            ;длина строк             

  PUSH ESI                        ;сохраняем регистры
  PUSH EDI

  MOV ECX,L                       ;CX = длина строк
  SHR ECX,5        
  ; Функции сдвига (сдвиг логический операнда влево/вправо)
  ; SHL операнд, количество_сдвигов         SHR операнд, количество_сдвигов
  ; SHL и SHR сдвигают биты операнда (регистр/память) влево или вправо
  ; соответственно на один разряд. Указанное выше действие повторяется
  ; количество раз, равное значению второго операнда.  
  
  ; Теперь по нашему коду. Сдвигаем на 5 разр€дов вправо.
  ; Если ECX больше или равен 32, то он станет 1, иначе 0
  
  INC ECX                         
  ; Инкрементируем ECX, чтобы цикл снизу выполнился 1 раз, если меньше 32 бит 
  ; и 2 раза, если битов все таки больше
  MOV EDI,X
  MOV ESI,Y
  ; Сразу будем разбирать на примере. Пусть X = 1010, а Y = 1000

M1:
  MOV EAX,[ESI]
  ; Помещаем Y(1000) как результат работы подпрограммы 
  OR EAX, [EDI]
  ; Логическое ИЛИ вычисляется с помощью команды OR. У этой команды 2
  ; операнда, и результат помещается на место первого.
  ; Значит в нашем случае мы получаем X or Y = 1010 
  ADD EDI,4                   
  ADD ESI,4
  ; Cдвигаем указатели строк на 4. Мы это уже проделывали в подсчёте. Как я и
  ; говорил тогда - это сдвиг на 4 байта, 32 бита. Ответ 1010, что правильно
  ; Первая итерация 
  LOOP M1                         

  POP EDI
  POP ESI
  POP EBP
  RET 12
X_U_Y ENDP
END