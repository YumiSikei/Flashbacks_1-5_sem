;2.  Составить подпрограмму с именем Count типа
;      function (const S: LONGWORD; L:LONGWORD)
;возвращающую число единиц битовой строки S длины L.


.386
.model FLAT,PASCAL
PUBLIC COUNT

.CODE
COUNT PROC

;Пролог(неполный)
push ebp          
mov ebp,esp      

; Опять дефайны  
S EQU dword ptr[ebp+12] ; наша строка  
L EQU dword ptr[ebp+8] ; длина строки
                      ; Перфекционист
					 ; внутри  меня в
					; полном восторге
				   ; Я же так никогда
				  ; не закончу писать
				 ; сей непревзоденный
				; комментарий. Браво!
				
				
push esi; 

; eax отвечает за то, что должна возвращать функция   
mov eax,0            
mov ebx,S                  
mov ecx,L           
mov esi,0    

; Цикл
M:
 bt [ebx], ESI 
 ; Команда BT копирует значение проверяемого бита в флаг CF. Считайте,
 ; что это как CMP, только для бит.
 ; команда BTR проверяет бит и затем сбрасывает его;
 ; команда BTS проверяет бит и затем устанавливает его в 1;
 ; команда BTC проверяет бит и затем инвертирует его.
 ; [ebx] - адрес, ESI - смещение
 
 adc eax, 0	
 ; Сложение с переносом. Определяет двоичную сумму двух указанных операндов и
 ; содержимого флага переноса CF. То есть тут записано следующее: eax + 0 + CF
 ; в eax хранится то, что вернется
 
 inc esi ; смещение растёт
 loop M 
 ; Алгоритм работы команды LOOP: 
 ; 1)CX = CX - 1
 ; 2)Если CX не равен 0, то выполнить переход
 ; 3)Иначе не выполнять переход, продолжить цикл
 ; У нас вместо CX есть ecx, и мы приравняли его к длине строки

  pop esi;
  pop ebp   ; Спасём стек     
  ret 8 ; на вход пришло 2 аргумента по 4 байта. Отсюда и восьмерка
COUNT ENDP
END