Turbo Assembler	 Version 5.3	    05-15-18 21:56:53	    Page 1
SetCler.ASM



      1					 ;Составить подпрограмму с именем SetCler типа
      2					 ;   Procedure (var S:LONGWORD;	L:LONGWORD; N:LONGWORD;	P:LONGWORD)
      3					 ;выполняющую установку	разряда	N битовой строки S
      4					 ;в ноль, если P=0, в единицу,если P не	равен 0.
      5
      6
      7					 ; заметки(с пробелом!)
      8					 ; LONGWORD занимает 4 байта, а	значит является	DWORD(DD)
      9
     10					 .386
     11					 ; директива, указывающая, что тип процессора Intel Pentium
     12
     13	00000000			 .model	FLAT,PASCAL
     14					 ; параметр flat указывает компилятору на то, что
     15					 ; будет использоваться	32-разрядная линейная адресация
     16					 ; Параметр соглашение_о_вызовах используется для определения способа
     17					 ; передачи параметров при вызове процедуры из других языков. У	нас ассемблер
     18
     19					 PUBLIC	SetCler
     20					 ; Каждая процедура или	функция	Турбо  Ассемблера,  которую  вы
     21					 ; хотите сделать доступной в программе	Турбо Паскаля, должна объяв-
     22					 ; ляться, как идентификатор PUBLIC, и ей должно  соответствовать  в
     23					 ; программе описание external (внешняя). Синтаксис описания внешней
     24					 ; процедуры или функции в  Турбо  Паскале  аналогичен	опережающему
     25					 ; (forward) описанию
     26
     27	00000000			 .CODE
     28					 ; Выше	было просто объявление,	что подпрограмма SetCler - должна запуститься
     29					 ; под турбоделфи, а теперь пишем ее определение.
     30
     31					 ;Макрос proc создает кадр стека, чтобы	можно было обрашаться к	параметрам
     32					 ; функции по именам. Если тебе	это не нужно делай так
     33	00000000			 SetCler PROC
     34	00000000  55			   PUSH	EBP
     35	00000001  8B EC			   MOV EBP,ESP
     36
     37
     38
     39					    ; ptr - Операция назначения	типа. Результатом будет	ссылка на память
     40					    ; со значением выражения, следующего за операцией и	типом выражения
     41					    ; перед операцией. S, L, N,	P - произвольные имена переменных, логично.
     42
     43					    ; В	случае с процессорами Intel, ровно как и со многими другими архитетурами,
     44					    ; стек растет в направлении	меньших	адресов	памяти.	Поэтому	верхушка,
     45					    ; в	данном случае, соответствует наименьшему адресу	в стеке. Какой гений это придумал,  +
     46					 какой блин гений
     47
     48					    ; Здесь знак +, что	означает, что переменные являются нелокальными - это
     49					    ; аргументы	функций. Но сами S,
     50
     51
     52					     ; Директива equ позволяет назначать имена переменных и констант. Причём
     53						 ; работает это	как дефайн в Си.
     54
     55						 ; По поводу числе +8, 12 и т.д. Если подпрограмма является far	или near, то
     56						 ; написав надпись PROC(во время определения функции), мы автоматически	занесем
     57						 ; в стек 4 или	2 байта	соответственно.	Сама EBP весит 4 байта.	Мы его запушили
Turbo Assembler	 Version 5.3	    05-15-18 21:56:53	    Page 2
SetCler.ASM



     58						 ; Отсюда число	+8. Теперь что касается	+12, +16, +20. По соглашению паскаля
     59						 ; параметры передаются	в функцию в прямом порядке, поэтому и обращаемся мы к ним так
     60		  = DWORD PTR[EBP+20]	   S EQU DWORD PTR[EBP+20]	   ;наша строка
     61		  = DWORD PTR[EBP+16]	   L EQU DWORD PTR[EBP+16]	   ;длина строки
     62		  = DWORD PTR[EBP+12]	   N EQU DWORD PTR[EBP+12]	   ;номер разряда
     63		  = DWORD PTR[EBP+8]	   P EQU DWORD PTR[EBP+8]	   ;параметр
     64
     65	00000003  56			   PUSH	ESI
     66
     67	00000004  8B 75	0C		   MOV ESI,N
     68	00000007  8B 5D	14		   MOV EBX,S
     69	0000000A  83 FE	20		   CMP ESI,32
     70	0000000D  76 0A	90 90 90 90	   JNA M0  ; Если номер	разряда	меньше или равен 32, то	в М0
     71
     72	00000013  83 EE	20		   SUB ESI,32 ;	Иначе номер разряда -= 32;
     73	00000016  83 C3	04		   ADD EBX,4 ; смещаем адрес строки на 4 байта вправо(как раз уйдет 32 бита)
     74
     75	00000019			 M0:
     76	00000019  83 7D	08 00		   CMP P,0			 ;сравниваем режим с нулем
     77	0000001D  74 0C	90 90 90 90	   JE M1			 ;если равно, то переходим на метку M1
     78	00000023  0F AB	33		   BTS [EBX], ESI		 ;установка бита в 1
     79					   ; Команда BTS сохраняет значение бита, из первого операнда со смещением,
     80					   ; указанным вторым операндом, во флаге CF, а	затем устанавливает этот бит
     81					   ; в 1. В нашем случае [EBX] - адрес строки. ESI - разряд.
     82	00000026  EB 06	90 90 90	   JMP M2
     83	0000002B			 M1:
     84	0000002B  0F B3	33		   BTR [EBX], ESI		 ;установка бита в 0
     85					   ; извлечение	значения заданного бита	в флаг cf и
     86					   ;  изменение	его значения на	нулевое.
     87
     88	0000002E			 M2:
     89	0000002E  5E			   POP ESI	   ;восстанавливаем регистры
     90	0000002F  5D			   POP EBP
     91	00000030  C2 0010		   RET 16
     92					   ; RET N(где N - это число байт передаваемых,	 то есть за-
     93					   ; несенных в	стек, параметров). Как я понимаю ret - умный удалятор из стека
     94					   ; Этакий всесильный pop... Хотя наверняка если указать невозможное число, не
     95					   ; кратное двойке все	крашнется...
     96
     97					   ; По	соглашению паскаля мы должны сами очищать память. RET это и делает
     98					   ; Прошу заметить, что это процедура и тут ничего не должно было вернуться
     99	00000033			 SetCler ENDP
    100					 END
Turbo Assembler	 Version 5.3	    05-15-18 21:56:53	    Page 3
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "05-15-18"
??FILENAME			  Text	 "SetCler "
??TIME				  Text	 "21:56:53"
??VERSION			  Number 0503
@32BIT				  Text	 1
@CODE				  Text	 FLAT
@CODESIZE			  Text	 0
@CPU				  Text	 0F0FH
@CURSEG				  Text	 _TEXT
@DATA				  Text	 FLAT
@DATASIZE			  Text	 0
@FILENAME			  Text	 SETCLER
@INTERFACE			  Text	 004H
@MODEL				  Text	 1
@STACK				  Text	 FLAT
@WORDSIZE			  Text	 4
L				  Text	 DWORD PTR[EBP+16]
M0				  Near32 FLAT:0019
M1				  Near32 FLAT:002B
M2				  Near32 FLAT:002E
N				  Text	 DWORD PTR[EBP+12]
P				  Text	 DWORD PTR[EBP+8]
S				  Text	 DWORD PTR[EBP+20]
SETCLER				  Near32 FLAT:0000

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  32  0000 Dword  Public  DATA
FLAT				  Group
_TEXT				  32  0033 Dword  Public  CODE
